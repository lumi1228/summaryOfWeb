#### 1. 什么是堆

* 堆是一种特殊的完全二叉树；
* 二叉树中除最后一层其他是完全填满的，若最后一层未填满，只缺少右边的若干节点
* JS中通常用 Array 表示堆（广度）
  * 左侧子节点位置是 2*index+1
  * 右侧子节点位置是 2*index+2
  * 父节点位置是(index-1)/2

  
#### 2.应用场景

* 快速的找出最大值和最小值，时间复杂度O[1](返回数组的第一个元素)
* 找出第K个最大(小)元素
  * 构建一个最小堆，并将元素依次插入堆中。
  * 当堆容量超过K，就删除堆顶。
  * 插入结束后，堆顶就会第k个最大元素

#### 2-1.实现：最小堆类

实现步骤：
* 在类里，声明一个数组，用来装元素。
* 主要方法：插入、删除堆顶、获取堆顶、获取堆大小

插入
* 将值插入堆的底部即数组的尾部
* 然后上移：将这个值与它的父节点进行交换，直到父节点小于等于这个插入的值
* 大小为k的堆中插入元素的时间复杂度为 O(logk)堆的高度

删除堆顶
* 用数组尾部元素替换堆顶（直接删除堆顶会破坏堆结构）
* 下移：将新堆顶和他的子节点交换，直到子节点大于这个新堆顶
* ​大小为k的堆中插入元素的时间复杂度为 O(logk)堆的高度

获取堆顶 : 返回数组的头部

获取堆大小：返回数组的长度

```
class MinHeap{
  constructor(){
    this.heap = []
  }
  swap(i1,i2){
    const temp =this.heap[i1]
    this.heap[i1] =this.heap[i2]
    this.heap[i2] =temp
  }
  getparentIndex(index){
    return Math.floor((index-1)/2)
  }
  shiftUp(index){
    if(index ==0 ) return
    const parentIndex = this.getparentIndex(index)
    if(this.heap[parentIndex]>this.heap[index]){
      this.swap(parentIndex,index)
      this.shiftUp(parentIndex)
    }
  }
  // 插入
  insert(value){
    this.heap.push(value)
    //上移
    this.shiftUp(this.heap.length-1)
  }

  getleftIndex(index){
    return 2*index + 1
  }
  getrightIndex(index){
    return 2*index + 2
  }
  shiftDown(index){
    const leftIndex = this.getleftIndex(index)
    const rightIndex = this.getrightIndex(index)
    if(this.heap[leftIndex]<this.heap[index]){
      this.swap(leftIndex,index)
      this.shiftDown(leftIndex)
    }
    if(this.heap[rightIndex]<this.heap[index]){
      this.swap(rightIndex,index)
      this.shiftDown(rightIndex)
    }
  }
  //删除堆顶
  pop(){
    this.heap[0]=this.heap.pop()
    // 下移 参数为要下移的下标
    this.shiftDown(0)
  }
  //获取堆大小
  peek(){
    return this.heap[0]
  }

  //获取堆顶
  size(){
    return this.heap.length
  }
}

const h1=new MinHeap()
h1.insert(5)
h1.insert(6)
h1.insert(5)
h1.insert(3)
h1.insert(1)

h1.pop()
h1.peek()
h1.size()
```

#### 3.算法题

* [🧡 215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
* [🧡 347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/) 📌
* [💜 23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)
