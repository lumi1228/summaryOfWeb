#### 1.排序和搜索是什么

* 排序：把某个乱序的数组变为升序或者降序的数组
* 搜索：找出数组中某个元素的下标
* JS中的排序：数组的 sort 方法
* JS中的搜索：数组的 indexOf 方法
* 排序算法：冒泡/选择/插入/归并/快速排序
* 搜索算法： 顺序/二分搜索
* 排序动画的网站：Visualgo.net

> * 冒泡排序
> * 选择排序
> * 插入排序
> * 归并排序「分而治之」 🌟🌟🌟📌
> * 快速排序「分而治之」 🌟🌟🌟📌
> * 顺序搜索
> * 二分搜索「分而治之」 🌟🌟🌟📌❓


#### 2. 冒泡排序

* 比较所有相邻元素，如果第一个比第二个大，则交换他们
* 一轮下来，可以保证最后一个数是最大的
* 执行n-1轮，就可以完成排序
* 时间复杂度 O(n^2) 两个嵌套循环

```
// 升序
Array.prototype.bubbleSort = function(){
  // 执行n-1轮
  for (let i = 0; i < this.length; i++) {
     // 比较所有相邻元素，如果第一个比后面的大，则交换他们
    for(let j =0;j < this.length-1-i ; j++){
      if( this[j] > this[j+1]){
        let temp = this[j+1]
        this[j+1]=this[j]
        this[j]=temp
      }
    }
  }
}
let arr = [5,4,3,2,1]
arr.bubbleSort() //[1, 2, 3, 4, 5]
```

#### 3. 选择排序

* 找到数组中的最小值，选中它并将其放置在第一位
* 接着找到第二小的值，选中它将其放置在第二位
* 以此类推，执行n-1轮
* 时间复杂度 O(n^2) 两个嵌套循环

```
// 升序
Array.prototype.selectionSort = function(){
  for (let i = 0; i < this.length; i++) {
    let indexMin = i 
    for (let j = i; j < this.length; j++) {
      // 找到数组中的最小值
      if (this[j] < this[indexMin]){
        indexMin =  j
      }
    }
    //将最小值与第i位交换
    if (indexMin !== i){
      let temp = this[indexMin]
      this[indexMin] = this[i]
      this[i] = temp
    }
  }
}
let arr = [5,4,3,2,1]
arr.selectionSort() //[1, 2, 3, 4, 5]
```

#### 4. 插入排序 *****

* 从第二个数开始往前比
* 比它大就往后排
* 以此类推进行到最后一个数
* 时间复杂度 O(n^2) 两个嵌套循环

```
// 升序
Array.prototype.insertionSort = function(){
   // 从第二个数开始往前比
  for(let i=1; i < this.length; i++){
    // 比它大就往后排
    let temp = this[i]
    let j = i
    while (j > 0) {
      //只要前面的值大，就直接后移
      if (this[j - 1] > temp) {
        this[j] = this[j - 1]
      } else {
        // 直到碰到小于等于当前值的就跳出循环（因为前面的值更小）
        break;
      }
      j -= 1
    }
    this[j] = temp
  }
  console.log(this)
}
let arr = [5,4,3,2,1]
arr.insertionSort() //[1, 2, 3, 4, 5]
```

#### 5. 归并排序「分而治之」 *****

* 分：把数组劈成两半，再再递归地对子数组进行“分”操作，直到分成一个个单独的数
* 合：把两个数合并为有序数组，再对有序数组合并，直到全部子数组合并为一个完整数组
  * 新建一个空数组res，用于存放最终排序后的数组
  * 比较两个有序数组的头部，较小者出队并推入res中
  * 如果两个数组还有值则重复第二步
* 时间复杂度 O(n*logN)，分的时间复杂度 O(logN)；合的时间复杂度 O(n)while循环体

```
// 升序
Array.prototype.mergeSort = function(){
  // 从第二个数开始往前比
  const rec=(arr)=>{
    if(arr.length ===1) {return arr}
    // 把数组劈成两半
    let mid = Math.floor(arr.length/2)
    let left = arr.slice(0,mid)
    let right = arr.slice(mid,arr.length)
    // 再递归地对子数组进行“分”操作，直到分成一个个单独的数
    const orderLeft = rec(left)  //[4,5]  //[3]
    // 存放 分成的单个数 或者排好的有序数组
    const orderRight = rec(right)        //[1,2]  //[1,2,3]
    
    // 新建一个空数组res，用于存放最终排序后的数组
    const res=[]
    // 比较两个有序数组的头部，较小者出队并推入res中
    while(orderLeft.length || orderRight.length){
      if(orderLeft.length && orderRight.length){
        res.push(orderLeft[0] < orderRight[0] ? orderLeft.shift():orderRight.shift())
      }else if(orderLeft.length){
        res.push(orderLeft.shift())
      }else if(orderRight.length){
        res.push(orderRight.shift())
      }
    }
    // 将排好的有序数组返回
    return res
  }
  const res = rec(this) // 排序后结果
  res.forEach((n,i)=>this[i]=n) // 改变原数组
  
}
let arr = [5,4,3,2,1]
arr.mergeSort() //[1, 2, 3, 4, 5]
```


#### 6. 快速排序「分而治之」 *****

* 分区：从数组中任意选择一个“基准”，所有比基准小的元素排在基准前面，比基准大的元素放在基准后面，这时基准的位置就是最终排序位置。
* 递归：递归地对基准前后的子数组进行分区。
* 时间复杂度 O(n*logN)，递归的时间复杂度O(logN)；分区的时间复杂度 O(n) for循环体

```
// 升序
Array.prototype.quickSort = function(){
  const rec =(arr)=>{
    if(arr.length ===1){return arr}
    const mid = arr[0]
    const left =[]
    const right =[]
    arr.forEach((n,i)=> {
      if(n < mid){
        left.push(n)
      }else if(n > mid){
        right.push(n)
      }
    });
    const orderLeft = rec(left)
    const orderRight = rec(right)
    return [...orderLeft,mid,...orderRight]
  }
  const res = rec(this) // 排序后结果
  res.forEach((n,i)=>this[i]=n) // 改变原数组
}
let arr = [2,4,5,3,1]
arr.quickSort() //[1, 2, 3, 4, 5]
```

#### 7. 顺序搜索

* 遍历元素
* 找到跟目标值相等的元素，就返回下标
* 遍历结束后，如果没有搜索到目标值，就返回-1
* 时间复杂度 O(n) 循环操作

```
Array.prototype.sequentialSearch = function(val){
  for (let i = 0; i < this.length; i++) {
    if(this[i] ===val){
      return i
    }
  }
  return -1
}

let arr = [2,4,5,3,1]
// arr.sequentialSearch(3) //[1, 2, 3, 4, 5]
console.log(arr.sequentialSearch(0))
```

#### 8. 二分搜索「分而治之」

* 前提：数组是有序的
* 从数组中间元素开始，如果中间元素正好是目标值，则搜索结果结束
* 如果目标值大于或者小雨目标元素，则在大于或者小于目标元素的那一半数组中搜索
* 时间复杂度 O(logN) 每次比较都使搜索范围缩小一半

```
Array.prototype.binarySearch = function(val){
  let low = 0
  let high =this.length-1
  while(low <= high){
    let mid = Math.floor((high+low)/2)
    if(val === this[mid]) {
      return mid
    }else if(val < this[mid]){
      high = mid -1
    } else{
      low = mid +1
    }
  }
  return -1
}

let arr = [1, 2, 3, 4, 5]
let res =[1, 2, 3, 4, 5].binarySearch(1)
console.log(res)
// arr.sequentialSearch(3) //[1, 2, 3, 4, 5]
```


#### 9.算法题

* [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
* [374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/) 「二分搜索+迭代」 🌟🌟🌟
