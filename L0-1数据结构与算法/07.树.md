#### 1. 什么是树

* 一种分层数据的抽象模型
* 前端工作中常见的树结构：DOM树、级联选择、树形控件
* JS中没有树，但可以用 Object 和 Array构建树
* 树的常用操作：**深度/广度优先遍历、先中后序遍历**

##### 1-1.树的深度优先遍历

* 深度优先遍历：尽可能深的搜索树的分支。
* 访问根节点。
* 对根节点的children挨个进行深度优先遍历

```
const tree = {
    val: 'a',
    children: [
        {
        val: 'b',
        children: [
            {
                val: 'd',
                children: []
            },
            {
                val: 'e',
                children: []
            }
        ]
        },
        {
            val: 'c',
            children: [
                {
                    val: 'f',
                    children: []
                }, {
                    val: 'g',
                    children: []
                }
            ]
        }
    ]
}
const dfs=(root)=>{
    console.log(root.val)
    a = root.val
    if (root.children.length) {
        root.children.forEach((item)=>{
            dfs(item)
        })
    }
}
dfs(tree) //a b d e c f g
```

##### 1-2.树的广度优先遍历

* 新建一个队列，先把根节点入队
* 把对队对头出队并访问
* 把队头的children挨个入队
* 重复第二三步，直到队列为空

```
const bfs=(root)=>{
    var q=[root];

    // if (root.children.length) {
    //     root.children.forEach((item) => {
    //         arr.push(item)
    //     })
    // }
    while(q.length){
        const fir=q.shift()
        console.log(fir.val)
        fir.children.forEach(child => {
            q.push(child)
        });
    }
}
bfs(tree) //a b c d e f g
```


#### 2. 二叉树

* 树中每个节点最多只能有两个子节点
* 在Js中通常用Object来模拟二叉树
* ！非递归版待练习

##### 2-1.二叉树先序遍历（根左右）

* 访问根节点
* 对根节点左子树进行先序遍历
* 对根节点右子树进行先序遍历

```
const bt = {
    val: 1,
    left: {
        val: 2,
        left: {
            val: 4,
            left: null,
            right: null
        },
        right: {
            val: 5,
            left: null,
            right: null
        }
    },
    right: {
        val: 3,
        left: {
            val: 6,
            left: null,
            right: null
        },
        right: {
            val: 7,
            left: null,
            right: null
        }
    }
}
// 方法1、递归
const preorder=(root)=>{
    if (!root) return;
    console.log(root.val)
    preorder(root.left)
    preorder(root.right)
}
preorder(bt) // 1 2 4 5 3 6 7

// 方法2、栈+迭代
// 新建栈的数据结构stack，将树的根节点入栈
// 遍历stack，始终取栈最后一个元素，将其右子树和左子树分别入栈；
// 因为栈有先进后出的特点，取值顺序为根左右，故入栈时，要先入栈右子树，以便遍历时优先取到左子树
// 根节点入栈，判断根
const preorder = (root) => {
    if (!root) return;
    const stack=[root]
    while(stack.length){
        const n = stack.pop()
        console.log(n.val)
        // 因为栈先进后出，入栈顺序right、left，以便取值顺位为left、right
        if (n.right) stack.push(n.right);
        if (n.left) stack.push(n.left);
     }
}
preorder(bt) // 1 2 4 5 3 6 7
```

##### 2-2.二叉树中序遍历（左根右）

* 对根节点左子树进行中序遍历
* 访问根节点
* 对根节点右子树进行中序遍历

```
// 方法1、递归
const inorder=(root)=>{
    if (!root) return;
    inorder(root.left)
    console.log(root.val)
    inorder(root.right)
}
inorder(bt)// 4 2 5 1 6 3 7

// 方法2、栈+迭代
const inorder = (root) => {
    if (!root) {return;}
    const stack = [];
    let p = root
    while (stack.length || p) {
        // 入栈left元素 1 2 4
        while (p) {
            stack.push(p)
            p = p.left;
        }

        const n = stack.pop()
        console.log(n.val) 
        p = n.right 
    }
}
inorder(bt)
// 入栈 1 2 4 [1,2,4]
// 出栈 4 [1,2]

// 右->3  入栈 5 [1,2,5]
// 出栈 5 [1,2]
//  右 - >3  


// 4 2 5 1 6 3 7
```

##### 2-3.二叉树后序遍历（左右根）

* 对根节点左子树进行后序遍历
* 对根节点右子树进行后序遍历
* 访问根节点

```
// 方法1、递归
const postorder=(root)=>{
    if (!root) return;
    postorder(root.left)
    postorder(root.right)
    console.log(root.val)
}
postorder(bt)// 4 5 2 67 3 1

// 方法2、栈+迭代
const postorder = (root) => {
    if (!root) return;
    const outputStack=[]
    const stack = [root]
    while (stack.length) {
        const n = stack.pop()
        outputStack.push(n)
        // 因为栈先进后出，入栈顺序right、left，以便取值顺位为left、right
        if (n.left) stack.push(n.left);
        if (n.right) stack.push(n.right);
    }
    while (outputStack.length) {
        const n = outputStack.pop()
        console.log(n.val)
    }
}
postorder(bt) // 4 5 2 67 3 1
```



#### 3.前端与树

* 遍历JSON的所有节点值

```
const json={
    a:{b:{c:1}},
    d:[1,2]
}

const dfs=(n,path)=>{
    //当前节点
    console.log(n,path);
    //当前节点children节点
    // console.log(Object.keys(n))
    Object.keys(n).forEach(item=>{
      console.log(n,item)
        dfs(n[item],path.concat(item));
    })
    
}
dfs(json,[])
// { a: { b: { c: 1 } }, d: [ 1, 2 ] }  == []
// { b: { c: 1 } }  == [ 'a' ]
// { c: 1 }  == [ 'a', 'b' ]
// 1  == [ 'a', 'b', 'c' ]
// [ 1, 2 ]  == [ 'd' ]
// 1  == [ 'd', '0' ]
// 2  == [ 'd', '1' ]
```

* 渲染Antd的树的组件  --待练习


#### 4.算法题

* 深度优先遍历🌟🌟🌟🌟🌟
* [145. 二叉树的后序遍历-栈/字节 🌟🌟🌟](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) 📌 
* [🧡 94. 二叉树的中序遍历-HOT100/字节/腾讯 🌟🌟🌟](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) 【迭代！】 📌 
* [144. 二叉树的前序遍历-字节/腾讯  🌟🌟🌟](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) 📌 
* [🧡 102.二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) 【广度优先遍历】📌 
* [104.二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)【深度优先遍历！】📌 
* [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)【广度优先遍历！】📌 
* [112.路径总和](https://leetcode-cn.com/problems/path-sum/)  【深度优先遍历】📌
* [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/) 
* [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/) 
* [💜 124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)  ⭕
