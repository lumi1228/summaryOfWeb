

> [参考：HTTP 网络请求-SY](https://www.mianshipai.com/docs/first-exam/HTTP.html#tcp-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B) 



### 1、TCP 是如何建立连接的，三次握手，四次挥手「京东」🌟🌟🌟🌟🌟

[参考：输入url到页面渲染前半段](https://juejin.cn/post/7350107540327022601) 

<details>
  <summary>结果</summary>

数据传输前必须先建立连接->三次握手：
* 客户端向服务端发送建立连接请求，客户端进入 SYN-SEND 状态
* 服务端收到建立连接请求后，向客户端发送一个应答，服务端进入 SYN-RECEIVED 状态
* 客户端接收到应答后，向服务端发送确认接收到应答，客户端进入 ESTABLISHED 状态

传输结束后需断开连接->四次挥手：
* 客户端向服务端发送断开连接请求
* 服务端收到断开连接请求后，告诉应用层去释放 tcp 连接
* 服务端向客户端发送最后一个数据包 FINBIT ，服务端进入 LAST-ACK 状态
* 客户端收到服务端的断开连接请求后，向服务端确认应答

三次握手四次挥手，客户端都是主动方，服务端都是被动方。在状态方面：三次握手的客户端和服务端都是由原来的 closed 变为 established，四次挥手的客户端和服务端都是由原来的 established 变为 closed。

结合前端场景的补充：
> 前端的 HTTP 请求（如 fetch、axios 调用）本质是 “先通过三次握手建立 TCP 连接，再传输 HTTP 数据，最后四次挥手断开”（短连接场景）。
为了优化性能，HTTP/1.1 默认启用 Keep-Alive 长连接，减少频繁三次握手 / 四次挥手的开销，让多个请求复用同一个 TCP 连接（这也是前端性能优化中 “减少连接建立成本” 的核心逻辑）。


</details>



什么是跨域？如何实现跨域通讯？


### 2、HTTP 请求跨域时为何要发送 options 请求「京东1、小米1」


 [参考：如何减少 options 请求](https://juejin.cn/post/7403185402347159588) 

 <details>
  <summary>结果</summary>

> MS简单版回答
* *跨域时的OPTIONS请求是浏览器的 “预检请求”，属于CORS机制：
* 仅仅针对 “非简单请求”（如PUT方法、Content-Type: application/json等）；
* 作用是提前向服务器确认 “是否允许该请求的方法、头部”，避免不安全的跨域操作对服务器产生副作用；
* 服务器允许后才会发送实际请求，是浏览器对跨域安全的一种保护机制。

#### 触发条件：

* 使用非简单请求方法：除 GET、POST、HEAD 之外的方法
* 使用非简单请求头：除 Accept、Accept-Language、Content-Language、Content-Type 之外的请求头
* Content-Type 不是以下之一：
  * application/x-www-form-urlencoded
  * multipart/form-data
  * text/plain

#### 工作流程：

浏览器发送 OPTIONS 预检请求，包含：

Origin：请求来源
Access-Control-Request-Method：实际请求使用的方法
Access-Control-Request-Headers：实际请求使用的请求头
服务器响应预检请求，返回：

Access-Control-Allow-Origin：允许的源
Access-Control-Allow-Methods：允许的方法
Access-Control-Allow-Headers：允许的请求头
Access-Control-Max-Age：预检请求的缓存时间
如果预检通过，浏览器才会发送实际请求

#### 优化建议：

尽可能使用简单请求，避免触发预检
合理设置 Access-Control-Max-Age 缓存预检结果
服务端正确配置 CORS 响应头

</details>


### 3、WebSocket 和 HTTP 协议有什么区别「京东1」


 <details>
  <summary>MS简洁-WebSocket 和 HTTP 的核心区别在于通信模式和连接特性结果</summary>

WebSocket 和 HTTP 的核心区别在于通信模式和连接特性：
* HTTP 是 “请求 - 响应” 的单向协议，无状态，适合非实时场景；
* WebSocket 是 “全双工” 的双向协议，有状态且持久连接，适合实时通信；
* 前者依赖客户端主动请求，后者支持双方主动推送，各自解决不同场景的需求。

</details>


 <details>
  <summary>结果-SY</summary>

WebSocket 和 HTTP 的主要区别：

#### 连接特性

HTTP 是短连接：每次请求都需要建立新的 TCP 连接（除非使用 keep-alive）
WebSocket 是持久化的长连接：只需要一次握手，后续可以持续通信

#### 通信方式

HTTP 是单向通信：客户端请求，服务器响应
WebSocket 是双向通信：客户端和服务器都可以主动发送数据

#### 数据格式

HTTP 每次请求都要带完整的 HTTP 头
WebSocket 第一次握手完成后，后续数据传输只需要很小的头部

#### 应用场景

HTTP 适合一次性的数据交互
WebSocket 适合实时性要求高的场景，如：实时聊天、游戏实时数据、实时协作文档

#### 性能

WebSocket 的性能和效率通常优于 HTTP 轮询
WebSocket 可以更好地节省服务器资源和带宽

#### 支持性

HTTP 被所有浏览器支持
WebSocket 需要浏览器支持（现代浏览器普遍已支持）


</details>



### 4、什么是跨域？如何实现跨域通讯？「京东1」


<details>
  <summary>MS简洁</summary>

  跨域是浏览器同源策略（协议、域名、端口需一致）导致的限制，目的是保障安全；

  实现跨域的核心方案：
  > 现代项目首选CORS（服务器设置响应头，支持所有请求类型）；
  > 兼容性需求用JSONP（仅支持 GET，依赖 script 标签）；
  > 开发环境用代理服务器（webpack/Vite 代理转发）；
  > 页面间通讯用postMessage（iframe 或多窗口场景）。
</details>


 <details>
  <summary>结果-SY</summary>
> 跨域是指浏览器的同源策略限制，当前域名的 JavaScript 代码试图访问其他域名下的资源时会受到限制。

同源的定义：

协议相同（http/https）
域名相同
端口相同


#### 跨域解决方案：

##### CORS（跨域资源共享）
服务器设置 Access-Control-Allow-Origin 等响应头
可以配置允许的请求方法、请求头、是否允许携带认证信息等
最常用的跨域解决方案

##### JSONP
利用 <script> 标签不受同源策略限制的特点
只支持 GET 请求
需要服务器配合返回 JavaScript 代码

##### 代理服务器
开发环境：webpack-dev-server、vite 等的 proxy 配置
生产环境：Nginx 反向代理

postMessage

HTML5 标准中的 API
用于不同窗口间的跨域通信
可以在父子页面（iframe）或者多窗口间通信

##### WebSocket

建立在 TCP 之上的协议
天然支持跨域
适合需要实时通信的场景
document.domain（已废弃）

仅适用于主域名相同的情况
将子域和主域的 document.domain 设为相同的主域

##### 最佳实践：

优先使用 CORS，配置得当的情况下最安全
需要兼容旧浏览器时可以考虑 JSONP
开发环境优先使用代理服务器
特殊场景（如页面通信）可以考虑 postMessage
需要实时通信时使用 WebSocket

</details>


### 5、在网络层面可做哪些性能优化？「京东1」

[聊一聊前端性能优化](https://juejin.cn/post/7362080157237116978)

 <details>
  <summary>MS简洁</summary>

网络层面优化的核心是 “少请求、小体积、快连接、多复用”：

减少请求：合并资源、懒加载、精灵图；
减小体积：压缩（Gzip/Brotli）、图片用 WebP、代码精简；
优化连接：复用连接（HTTP/2/3）、CDN、预连接；
利用缓存：强缓存 + 协商缓存、哈希更新策略。
</details>


 <details>
  <summary>结果-SY</summary>

##### 减少请求数量

合并文件（CSS/JS 打包）
雪碧图（CSS Sprites）
图片懒加载
按需加载/异步加载
合理使用缓存

##### 减小资源体积

代码压缩（minify）
Gzip/Brotli 压缩
图片优化（压缩、webp格式）
Tree Shaking
代码分割（Code Splitting）

##### CDN 优化

使用 CDN 分发静态资源
合理设置 CDN 缓存
选择合适的 CDN 节点
配置 CDN 预热和刷新策略

##### HTTP 优化

使用 HTTP/2 多路复用
开启 Keep-Alive
合理设置缓存策略
DNS 预解析（dns-prefetch）
预连接（preconnect）
预加载（prefetch/preload）

##### 资源加载优化

关键资源优先加载
非关键资源延迟加载
内联关键 CSS/JS
异步加载非关键 JS（async/defer）
优化资源加载顺序

##### 接口优化

接口合并
GraphQL 按需查询
数据缓存
避免重复请求
设置合理的超时时间
监控和分析

##### 性能监控
错误监控
用户体验监控
性能数据分析
持续优化

</details>


### 6、在网络层面可做哪些性能优化？「京东1」

[聊一聊前端性能优化](https://juejin.cn/post/7362080157237116978)

 <details>
  <summary>MS简洁</summary>
整个过程可分为 “网络请求阶段” 和 “页面渲染阶段” 两大块，具体包括：
输入处理 → DNS 解析 → 建立连接 → 发送请求 → 接收响应 → 页面渲染

总结（简洁版）
从输入 URL 到渲染页面，核心流程是：
域名解析为 IP（DNS）；
建立 TCP（HTTPS 加 TLS）连接；
发送 HTTP 请求并接收响应；
解析 HTML 生成 DOM、解析 CSS 生成 CSSOM，结合为渲染树；
经过布局、绘制、合成，最终呈现页面。
这个过程涉及网络传输、资源解析和渲染优化，体现了浏览器从 “获取数据” 到 “可视化展示” 的完整工作流。


----------


#### 详细步骤（分阶段展开）
1. 输入处理（用户输入 URL）
浏览器首先判断输入内容：若为 “关键词”（如 “前端面试题”），则调用默认搜索引擎搜索；若为 “URL”（如https://www.example.com），则进入下一步。
浏览器会对 URL 进行校验（如补全协议，若输入www.example.com，自动补全为http://或https://）。

2. DNS 解析（域名→IP 地址）
浏览器需要将 “域名”（如www.example.com）转换为 “IP 地址”（如113.10.123.45），因为网络中实际通过 IP 定位服务器。
解析流程（缓存优先）：
浏览器缓存：检查自身缓存（如 Chrome 缓存 DNS 记录约 1 分钟），若有则直接使用；
操作系统缓存：浏览器缓存未命中时，查询操作系统 hosts 文件或系统 DNS 缓存；
路由器缓存：若前两步无结果，请求路由器缓存（家用路由器通常会缓存常用域名）；
DNS 服务器查询：向
本地 DNS 服务器（如电信 / 联通提供的 DNS）请求解析，若仍无结果，本地 DNS 会逐层向上查询（根域名服务器→顶级域名服务器→权威域名服务器），最终返回 IP。
优化点：DNS 缓存减少重复解析耗时；DNS 负载均衡（如 CDN 通过 DNS 返回离用户最近的节点 IP）。

3. 建立连接（TCP 握手 + HTTPS 加密）
获取 IP 后，浏览器与服务器建立网络连接，基于 TCP 协议（HTTP/1.1/2）或 QUIC 协议（HTTP/3）：
TCP 三次握手（HTTP/1.1/2）：
客户端发送SYN包（请求建立连接）；
服务器返回SYN+ACK包（同意连接）；
客户端发送ACK包（确认连接），连接建立。
HTTPS 额外步骤（TLS 握手）：
若 URL 是https，需在 TCP 连接基础上完成 TLS 加密：
客户端发送支持的加密套件，服务器返回证书（含公钥）；
客户端验证证书有效性（通过 CA 机构），生成随机密钥并用服务器公钥加密发送；
服务器用私钥解密，双方基于随机密钥生成会话密钥，后续数据用对称加密传输（更高效）。

4. 发送 HTTP 请求
连接建立后，浏览器向服务器发送 HTTP 请求（请求报文包含三部分）：
请求行：Method URL Version（如GET /index.html HTTP/1.1）；
请求头：携带浏览器信息（User-Agent）、缓存标识（If-None-Match）、Cookie 等（如Cookie: uid=123）；
请求体：POST 请求时携带数据（如表单参数），GET 请求无请求体。

5. 服务器处理并返回响应
服务器接收请求后，按逻辑处理（如查询数据库、拼接页面），返回 HTTP 响应（响应报文包含三部分）：
响应行：Version StatusCode Reason（如HTTP/1.1 200 OK）；
响应头：携带资源类型（Content-Type: text/html）、缓存策略（Cache-Control: max-age=3600）、压缩方式（Content-Encoding: gzip）等；
响应体：实际资源内容（如 HTML、CSS、JS 代码，或 JSON 数据）。

6. 页面渲染（核心前端环节）
浏览器接收响应后，若响应体是 HTML，开始渲染页面，核心步骤为：
DOM 构建 → CSSOM 构建 → 渲染树生成 → 布局 → 绘制 → 合成
① 构建 DOM 树（HTML→DOM）：
浏览器解析 HTML 字符串，按标签嵌套关系生成 “文档对象模型”（DOM 树），每个标签对应一个节点（如<div>→div节点）。
阻塞点：JS 会阻塞 DOM 解析（因为document.write()等操作可能修改 DOM），若 JS 在<head>且无async/defer，会暂停 DOM 解析，等待 JS 下载并执行完成后再继续。
② 构建 CSSOM 树（CSS→CSSOM）：
浏览器解析 CSS（包括内联样式、<style>标签、外部 CSS），生成 “CSS 对象模型”（CSSOM 树），记录每个节点的样式规则（如div { color: red }）。
阻塞点：CSS 会阻塞渲染（需与 DOM 结合生成渲染树），且会阻塞 JS 执行（JS 可能操作样式，需等待 CSSOM 就绪）。
③ 生成渲染树（Render Tree）：
结合 DOM 树和 CSSOM 树，过滤不可见节点（如display: none的元素、<head>标签），保留可见节点及其样式，形成渲染树（仅包含需要显示的内容）。
④ 布局（Layout/Reflow）：
根据渲染树计算每个节点的 “几何信息”（位置、宽高、边距等），确定节点在页面中的具体位置（如div左上角坐标(10px, 20px)，宽200px）。
触发场景：DOM 结构修改（如新增节点）、样式修改（如width变化）、窗口大小变化等，会导致布局重新计算（性能消耗较高）。
⑤ 绘制（Paint）：
按布局结果，将节点的样式 “绘制” 到屏幕上（如填充颜色、绘制文字、渲染图片），生成像素信息。
触发场景：样式修改不影响布局时（如color、background变化），仅触发绘制（性能消耗低于布局）。
⑥ 合成（Composite）：
浏览器将页面分为多个 “图层”（如视频层、动画层），分别绘制后合并成最终屏幕图像（减少重绘范围，提升性能）。
优化点：通过will-change: transform等属性提示浏览器创建独立图层，避免动画时整个页面重绘。
#### 补充细节（面试加分点）
缓存的影响：若请求的资源命中强缓存（Cache-Control），浏览器直接使用本地缓存，跳过网络请求；
HTTP/2 的优化：多路复用（同一连接并行传输多个资源）、头部压缩，减少连接开销；
回流与重绘：布局（回流）比绘制（重绘）更耗时，开发中应避免频繁修改宽高、位置等属性。

</details>