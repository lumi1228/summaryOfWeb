### 1、手写深拷贝 
[参考：深拷贝的终极探索（99%的人都不知道）](https://segmentfault.com/a/1190000016672263) + SY 💛💛

> 深拷贝会另外拷贝一份一个一样的对象,
> 但是不同的是会从堆内存中开辟一个新的区域存放新对象,
> 新对象跟原对象不再共享内存，修改赋值后的对象b不会改到原对象a。

<details>
  <summary>1-手写递归方法</summary>
实现思路：

1.判断是否是对象类型，不是则直接返回
2.初始化类型：数组或对象
3.保证key不是原型的属性
4.递归调用返回值
```
/**
 * 深拷贝
 * @param {Object} obj 要拷贝对象
 */
function deepClone(obj) {
    if (!(obj instanceof Object)) return obj;
    let res
     //初始化返回结果
    if (obj instanceof Array) {
        res=[]
    }else{
        res={}
    }
    for (let key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) {
            // 保证key不是原型的属性
            res[key]=deepClone(obj[key])//递归调用！！
        }
    }
    return res //返回结果
}    
```



</details>


<details>
  <summary> 2-使用JSON.parse(JSON.stringify()) </summary>

实现原理：
用JSON.stringify将JSON对象转成JSON字符串，
再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。 

缺点：
由于用到了JSON.stringify()，这也会导致一系列的问题，因为要严格遵守JSON序列化规则： 

* 如果含有**Date对象**，JSON.stringify()会将其变为字符串，**之后并不会将其还原为日期对象**。    
* 或是含有**RegExp对象**，JSON.stringify()会将其变为**空对象**
* 属性中含有**NaN、Infinity和-Infinity**，则序列化的结果会变成**null**
* 如果属性中有**函数,undefined,symbol**则经过JSON.stringify()序列化后的JSON字符串中这个**键值对会消失**，因为不支持。

</details>



### 2、数组去重「京喜、易车」

[参考：JavaScript专题之数据库去重](https://github.com/mqyqingfeng/Blog/issues/27) + SY 💛💛

> 前置知识：
> indexOf()方法可返回某个指定的元素在数组中首次出现的位置。
Array.prototype.filter()方法：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
Array.prototype.sort() 方法：对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的
Set：ES6新增的数据结构，它类似于数组，但是成员的值都是唯一的，没有重复的值。
Array.from()：方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。


<details>
  <summary>1.双for循环==for循环+indexOf</summary>

* 定义新数组(结果数组)；
* 遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对； 
* 如果不重复则添加到新数组中返回。
* 时间复杂度是O(n^2)
```
function noRepeat(arr){
if (!Array.isArray(arr)) return '非数组的数据';
let result=[arr[0]];// 初始化第一个数据
for (let i = 1; i < arr.length; i++) { // 从第二个元素开始判断
    var flag=true//默认 没有重复值
    for (let j = 0; j < result.length; j++) {
        if(arr[i] === result[j]){
            flag=false; //一旦有重复值就修改为 false,不可传入新数组
            break;//跳出内层循环
        }
    }
    if(flag){
        result.push(arr[i])
    }
}
return result;
}
```
等价于
```
function noRepeat(arr){
    if (!Array.isArray(arr)) return '非数组的数据';
    let result=[];// 初始化第一个数据
    for (let i = 0; i < arr.length; i++) { // 从第二个元素开始判断
        if(result.indexOf(arr[i]) === -1){
            result.push(arr[i])
        }
    }
    return result;
}
```

</details>

<details>
  <summary>2.Array.filter()+indexOf()</summary>

* 利用indexOf检测元素在数组中第一次出现的位置是否和元素现在的位置相等
* 若不相等则为重复元素，故只剪出相等即可包含所有非重复元素

```
function noRepeat(arr){
    if (!Array.isArray(arr)) return '非数组的数据';
    return arr.filter((item,index)=>{
        return arr.indexOf(item) ===index;
    })
}
```

</details>

<details>
  <summary>3.Array.sort()+相邻元素去重</summary>

```
function noRepeat(arr){
    if (!Array.isArray(arr)) return '非数组的数据';
    let arr2= arr.sort()
    let result=[]
    for (let i = 0; i < arr2.length; i++) {
        if(arr2[i] !== arr2[i+1]){
            result.push(arr2[i])
        }
    }
    return result;
}
```
</details>

<details>
  <summary>4.利用对象属性去重</summary>

* 将数组中的值设为对象的属性，并给该属性赋初始值1，
* 若非重复数据可以获得无该属性，则收集。
```
function noRepeat(arr){
    if (!Array.isArray(arr)) return '非数组的数据';
    let obj={}
    let result=[]
    for (let i = 0; i < arr.length; i++) {
        if(!obj[arr[i]]){
            obj[arr[i]]=1;
            result.push(arr[i])
        }
    }
    return result;
}
```
</details>

<details>
  <summary>5.new Set去重+rest不定参数+解构赋值</summary>

```
function noRepeat(arr){
    if (!Array.isArray(arr)) return '非数组的数据';
    return [...new Set(arr)] ;
}
```
</details>

<details>
  <summary>6.new Set去重+Array.from</summary>

```
function noRepeat(arr){
    if (!Array.isArray(arr)) return '非数组的数据';
    return Array.from(new Set(arr)) ;
}
```
</details>



### 3、手写 getType & instanceof函数

<details>
  <summary>1-getType「SY」</summary>

```
function getType(data) {
  // 获取到 "[object Type]"，其中 Type 是 Null、Undefined、Array、Function、Error、Boolean、Number、String、Date、RegExp 等。
  const originType = Object.prototype.toString.call(data)
  // 可以直接截取第8位和倒数第一位，这样就获得了 Null、Undefined、Array、Function、Error、Boolean、Number、String、Date、RegExp 等
  const type = originType.slice(8, -1)
  // 再转小写，得到 null、undefined、array、function 等
  return type.toLowerCase()
}
```

</details>

<details>
  <summary>2-instanceof「自己手写」</summary>

```
function instanceof1(left, right) {
    if (typeof left !== "object" && typeof left !== "function") {
        return "非引用类型"
    }
    var L = left.__proto__//取L的隐式原型
    var R = right.prototype//取R的显式原型

    while (R != null) {
        console.log('r',R )
        if(L === R){ 
            return true;
        }
        L=L.__proto__
    }
}
let arr = [1, 2]
console.log(instanceof1(arr, Array)) //true
console.log(instanceof1(arr, Object)) //true
        
```
</details>


### 4、手写 class 继承

[参考：JavaScript专题之数据库去重](https://github.com/mqyqingfeng/Blog/issues/27) + SY 💛💛

<details>
  <summary> 手写 class 继承</summary>

在某网页中，有三种菜单：button menu，select menu，modal menu。

他们的共同特点：

都有 title icon 属性
都有 isDisabled 方法（可直接返回 false）
都有 exec 方法，执行菜单的逻辑
他们的不同点：

button menu，执行 exec 时打印 'hello'
select menu，执行 exec 时返回一个数组 ['item1', 'item2', 'item3']
modal menu，执行 exec 时返回一个 DOM Element <div>modal</div>
请用 ES6 语法写出这三种菜单的 class

```
class BaseMenu {
  constructor(title, icon) {
    this.title = title
    this.icon = icon
  }
  isDisabled() {
    return false
  }
}

class ButtonMenu extends BaseMenu {
  constructor(title, icon) {
    super(title, icon)
  }
  exec() {
    console.log('hello')
  }
}

class SelectMenu extends BaseMenu {
  constructor(title, icon) {
    super(title, icon)
  }
  exec() {
    return ['item1', 'item2', 'item3']
  }
}

class ModalMenu extends BaseMenu {
  constructor(title, icon) {
    super(title, icon)
  }
  exec() {
    const div = document.createElement('div')
    div.innerText = 'modal'
    return div
  }
}
```

</details>


### 5、手写防抖 Debounce 「百度1、易车1」

[参考：JavaScript专题之跟着underscore学防抖](https://github.com/mqyqingfeng/Blog/issues/22) + SY 💛💛

<details>
  <summary>手写Debounce方法</summary>

```
function debounce(func, wait, immediate) {
  var timeout, result

  var debounced = function () {
    var context = this
    var args = arguments

    if (timeout) clearTimeout(timeout)
    if (immediate) {
      // 如果已经执行过，不再执行
      var callNow = !timeout
      timeout = setTimeout(function () {
        timeout = null
      }, wait)
      if (callNow) result = func.apply(context, args)
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args)
      }, wait)
    }
    return result
  }

  debounced.cancel = function () {
    clearTimeout(timeout)
    timeout = null
  }

  return debounced
}
```

</details>

### 6、手写截流 Throttle「百度1、易车1」

[参考：JavaScript专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26) + SY 💛💛

<details>
  <summary>手写throttle方法</summary>

```
  function throttle(func, wait, options) {
  var timeout, context, args, result
  var previous = 0
  if (!options) options = {}

  var later = function () {
    previous = options.leading === false ? 0 : new Date().getTime()
    timeout = null
    func.apply(context, args)
    if (!timeout) context = args = null
  }

  var throttled = function () {
    var now = new Date().getTime()
    if (!previous && options.leading === false) previous = now
    var remaining = wait - (now - previous)
    context = this
    args = arguments
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout)
        timeout = null
      }
      previous = now
      func.apply(context, args)
      if (!timeout) context = args = null
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining)
    }
  }
  throttled.cancel = function () {
    clearTimeout(timeout)
    previous = 0
    timeout = null
  }
  return throttled
}
```

</details>


### 7、手写 bind

[参考：JavaScript深入之bind的模拟实现](https://github.com/mqyqingfeng/Blog/issues/12) + SY 💛💛


<details>
  <summary>call、apply、bind的基本使用</summary>

```
let obj = {
    a: '李'
}
function allName(b) {
    console.log(this) //{a: "李"}
    return this.a + b;
}
console.log(allName.call(obj, '四')) // 李四

console.log(allName.apply(obj, ['二'])) // 李二

var fn = allName.bind(obj, '三')
console.log(fn()) // 李三     

```

</details>

<details>
  <summary>1、手写bind方法「SY」</summary>

* function.bind(thisArg[, arg1[, arg2[, ...]]])

> [MDN] bind() 方法创建一个新的函数，    
在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，   
而其余参数将作为新函数的参数，供调用时使用。   

```
Function.prototype.bind2 = function (context) {
  if (typeof this !== 'function') {
    throw new Error('Function.prototype.bind - what is trying to be bound is not callable')
  }

  var self = this
  var args = Array.prototype.slice.call(arguments, 1)

  var fNOP = function () {}

  var fBound = function () {
    var bindArgs = Array.prototype.slice.call(arguments)
    return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs))
  }

  fNOP.prototype = this.prototype
  fBound.prototype = new fNOP()
  return fBound
}
```

</details>

<details>
  <summary>2、bind方法「Own整理」</summary>

#####  理解bind函数
> bind方法主要的作用是将**函数绑定至某个对象**，当函数f()上调用bind()方法并传入对象o作为参数，这个方法将**返回一个新的函数**。

```
function f(y){return this.x+y} // step1.定义函数
var o={x:1} //step2.定义待传入的对象
var g=f.bind(o)//step3.f函数绑定至o对象, 返回一个新对象赋值给g
g(2) //3
```

#####  思路步骤：  
1. 在Function原型上定义方法bind1  
2. 将参数拆解为数组  
3. 获取this(数组第一项)、及函数传参  
4. 获取上下文(this):fn1.bind(...)中的fn1,存储为self  
5. 返回一个函数，函数内用self.apply实现函数的绑定  

```
// step0:在Function原型上定义方法bind1
Function.prototype.bind1=function(){
    // arguments:可以获取函数所有的参数
    console.log(arguments) //[{x: 100},10,20]
    // slice() 方法可从已有的数组中返回选定的元素。
    // step1:将参数拆解为数组
    
    const args = Array.prototype.slice.call(arguments)

    // step2:获取this(数组第一项)
    const this_ = args.shift() //shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。

    // 存储 fn1.bind(...)中的fn1
    const self = this //this指向fn1

    //返回一个函数
    return function(){
        return self.apply(this_, args)
    }
}
const fn3 = fn1.bind1({
    x: 100
}, 10, 20)
```

</details>


### 8、手写 call 和 apply

[参考：JavaScript深入之call和apply的模拟实现](https://github.com/mqyqingfeng/Blog/issues/11) + SY 💛💛

<details>
  <summary>手写手写 call 和 apply方法</summary>

* function.call(thisArg, arg1, arg2, ...)
> [MDN] call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。    
 call() 方法接受的是一个参数列表

 * func.apply(thisArg, [argsArray])

> [MDN] apply() 方法调用一个具有给定this值的函数，以及以一个数组（或类数组对象）的形式提供的参数。    
apply()方法接受的是一个参数数组。

```
Function.prototype.call2 = function (context) {
  var context = context || window
  context.fn = this

  var args = []
  for (var i = 1, len = arguments.length; i < len; i++) {
    args.push('arguments[' + i + ']')
  }

  var result = eval('context.fn(' + args + ')')

  delete context.fn
  return result
}

Function.prototype.apply = function (context, arr) {
  var context = Object(context) || window
  context.fn = this

  var result
  if (!arr) {
    result = context.fn()
  } else {
    var args = []
    for (var i = 0, len = arr.length; i < len; i++) {
      args.push('arr[' + i + ']')
    }
    result = eval('context.fn(' + args + ')')
  }

  delete context.fn
  return result
}
```
</details>


### 9、手写数组拍平 Array Flatten

[参考：JavaScript专题之数组扁平化](https://github.com/mqyqingfeng/Blog/issues/36) + SY 💛💛

<details>
  <summary>1- flatten方法「SY」</summary>

#### 前置知识-Own：

##### `Array.prototype.flat(depth)`特性：
* `Array.prototype.flat()`[ES10]：用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。
* 不传参数时，默认“拉平”一层
* 传入一个整数参数，整数即“拉平”的层数
* Infinity关键字作为参数时，无论多少层嵌套，都会转为一维数组
* 传入 <=0的整数将返回原数组，不“拉平”
* 如果原数组有空位，flat()方法会跳过空位。


```
function flatten(input, shallow, strict, output) {
  // 递归使用的时候会用到output
  output = output || []
  var idx = output.length

  for (var i = 0, len = input.length; i < len; i++) {
    var value = input[i]
    // 如果是数组，就进行处理
    if (Array.isArray(value)) {
      // 如果是只扁平一层，遍历该数组，依此填入 output
      if (shallow) {
        var j = 0,
          length = value.length
        while (j < length) output[idx++] = value[j++]
      }
      // 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output
      else {
        flatten(value, shallow, strict, output)
        idx = output.length
      }
    }
    // 不是数组，根据 strict 的值判断是跳过不处理还是放入 output
    else if (!strict) {
      output[idx++] = value
    }
  }

  return output
}
```
</details>



### 10、手写解析 URL 参数为 JS 对象

[参考：解析 URL 参数为对象和字符串模板](https://juejin.cn/post/6950554221242499103) + SY 💛💛

<details>
  <summary>解析 URL 参数为 JS 对象</summary>

```
function parseParam(url) {
  const paramsStr = /.+\?(.+)$/.exec(url)[1] // 将 ? 后面的字符串取出来
  //exec() 方法用于检索字符串中的正则表达式的匹配。
  const paramsArr = paramsStr.split('&') // 将字符串以 & 分割后存到数组中
  let paramsObj = {}
  // 将 params 存到对象中
  paramsArr.forEach((param) => {
    if (/=/.test(param)) {
      // 处理有 value 的参数
      let [key, val] = param.split('=') // 分割 key 和 value
      val = decodeURIComponent(val) // 解码
      val = /^\d+$/.test(val) ? parseFloat(val) : val // 判断是否转为数字
      //test() 方法用于检测一个字符串是否匹配某个模式.
      if (paramsObj.hasOwnProperty(key)) {
        // 如果对象有 key，则添加一个值
        paramsObj[key] = [].concat(paramsObj[key], val)
        //concat() 方法用于连接两个或多个数组。
        //该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。
      } else {
        // 如果对象没有这个 key，创建 key 并设置值
        paramsObj[key] = val
      }
    } else {
      // 处理没有 value 的参数
      paramsObj[param] = true
    }
  })

  return paramsObj
}
```
</details>