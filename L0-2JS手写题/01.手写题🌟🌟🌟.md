### 1、手写深拷贝
[参考：深拷贝的终极探索（99%的人都不知道）](https://segmentfault.com/a/1190000016672263) + SY 💛💛

> 深拷贝会另外拷贝一份一个一样的对象,
> 但是不同的是会从堆内存中开辟一个新的区域存放新对象,
> 新对象跟原对象不再共享内存，修改赋值后的对象b不会改到原对象a。

<details>
  <summary>1-手写递归方法</summary>
实现思路：

1.判断是否是对象类型，不是则直接返回
2.初始化类型：数组或对象
3.保证key不是原型的属性
4.递归调用返回值
```
/**
 * 深拷贝
 * @param {Object} obj 要拷贝对象
 */
function deepClone(obj) {
    if (!(obj instanceof Object)) return obj;
    let res
     //初始化返回结果
    if (obj instanceof Array) {
        res=[]
    }else{
        res={}
    }
    for (let key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) {
            // 保证key不是原型的属性
            res[key]=deepClone(obj[key])//递归调用！！
        }
    }
    return res //返回结果
}    
```



</details>


<details>
  <summary> 2-使用JSON.parse(JSON.stringify()) </summary>

实现原理：
用JSON.stringify将JSON对象转成JSON字符串，
再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。 

缺点：
由于用到了JSON.stringify()，这也会导致一系列的问题，因为要严格遵守JSON序列化规则： 

* 如果含有**Date对象**，JSON.stringify()会将其变为字符串，**之后并不会将其还原为日期对象**。    
* 或是含有**RegExp对象**，JSON.stringify()会将其变为**空对象**
* 属性中含有**NaN、Infinity和-Infinity**，则序列化的结果会变成**null**
* 如果属性中有**函数,undefined,symbol**则经过JSON.stringify()序列化后的JSON字符串中这个**键值对会消失**，因为不支持。

</details>



### 2、数组去重

[参考：JavaScript专题之数据库去重](https://github.com/mqyqingfeng/Blog/issues/27) + SY 💛💛

> 前置知识：
> indexOf()方法可返回某个指定的元素在数组中首次出现的位置。
Array.prototype.filter()方法：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
Array.prototype.sort() 方法：对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的
Set：ES6新增的数据结构，它类似于数组，但是成员的值都是唯一的，没有重复的值。
Array.from()：方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。


<details>
  <summary>1.双for循环==for循环+indexOf</summary>

* 定义新数组(结果数组)；
* 遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对； 
* 如果不重复则添加到新数组中返回。
* 时间复杂度是O(n^2)
```
function noRepeat(arr){
if (!Array.isArray(arr)) return '非数组的数据';
let result=[arr[0]];// 初始化第一个数据
for (let i = 1; i < arr.length; i++) { // 从第二个元素开始判断
    var flag=true//默认 没有重复值
    for (let j = 0; j < result.length; j++) {
        if(arr[i] === result[j]){
            flag=false; //一旦有重复值就修改为 false,不可传入新数组
            break;//跳出内层循环
        }
    }
    if(flag){
        result.push(arr[i])
    }
}
return result;
}
```
等价于
```
function noRepeat(arr){
    if (!Array.isArray(arr)) return '非数组的数据';
    let result=[];// 初始化第一个数据
    for (let i = 0; i < arr.length; i++) { // 从第二个元素开始判断
        if(result.indexOf(arr[i]) === -1){
            result.push(arr[i])
        }
    }
    return result;
}
```

</details>

<details>
  <summary>2.Array.filter()+indexOf()</summary>

* 利用indexOf检测元素在数组中第一次出现的位置是否和元素现在的位置相等
* 若不相等则为重复元素，故只剪出相等即可包含所有非重复元素

```
function noRepeat(arr){
    if (!Array.isArray(arr)) return '非数组的数据';
    return arr.filter((item,index)=>{
        return arr.indexOf(item) ===index;
    })
}
```

</details>

<details>
  <summary>3.Array.sort()+相邻元素去重</summary>

```
function noRepeat(arr){
    if (!Array.isArray(arr)) return '非数组的数据';
    let arr2= arr.sort()
    let result=[]
    for (let i = 0; i < arr2.length; i++) {
        if(arr2[i] !== arr2[i+1]){
            result.push(arr2[i])
        }
    }
    return result;
}
```
</details>

<details>
  <summary>4.利用对象属性去重</summary>

* 将数组中的值设为对象的属性，并给该属性赋初始值1，
* 若非重复数据可以获得无该属性，则收集。
```
function noRepeat(arr){
    if (!Array.isArray(arr)) return '非数组的数据';
    let obj={}
    let result=[]
    for (let i = 0; i < arr.length; i++) {
        if(!obj[arr[i]]){
            obj[arr[i]]=1;
            result.push(arr[i])
        }
    }
    return result;
}
```
</details>

<details>
  <summary>5.new Set去重+rest不定参数+解构赋值</summary>

```
function noRepeat(arr){
    if (!Array.isArray(arr)) return '非数组的数据';
    return [...new Set(arr)] ;
}
```
</details>

<details>
  <summary>6.new Set去重+Array.from</summary>

```
function noRepeat(arr){
    if (!Array.isArray(arr)) return '非数组的数据';
    return Array.from(new Set(arr)) ;
}
```
</details>

<details>
  <summary>1-手写递归方法</summary>
</details>

<details>
  <summary>1-手写递归方法</summary>
</details>