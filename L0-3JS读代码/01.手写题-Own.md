

> [参考：JS读代码-SY](https://www.mianshipai.com/docs/written-exam/JS-reading.html) 


## JS 编译

### 1、编译「变量提升、函数与变量声明优先级」

```
var func = 1
function func() {}
console.log(func + func)

```
<details>
  <summary>结果&分析</summary>

```
结果：2
```

编译阶段（提升发生） ：
- JavaScript 引擎在代码执行前会进行编译，此时会将 function func() {} 函数声明提升到当前作用域的顶部
- 同时也会将 var func 变量声明提升到作用域顶部，但 变量初始化（赋值为1）会留在原地
- 当函数声明和同名变量声明同时存在时， 函数声明的优先级高于变量声明

执行阶段 ：
- 首先执行 var func = 1 ，这会将之前提升的函数引用覆盖为数值 1
- 然后执行 function func() {} ，但由于变量已经被赋值，这个函数声明在执行阶段不会生效
- 最后执行 console.log(func + func) ，此时 func 的值是 1，所以 1 + 1 = 2

</details>


## JS 类型
## JS this
## JS 自由变量
## JS 闭包
## JS promise

### Promise执行顺序1「小米1」

> 参考文件 ./01.promise.js
 
 <details>
  <summary>Promise执行顺序「同步-异步（微任务-宏任务）</summary>

```
async function async1() {
    console.log('async1 start'); //2
    await async2();
    console.log('async1 end');//6
  }
  async function async2() {
    console.log('async2'); //3
  }
  
  console.log('script start'); //1
  
  setTimeout(function () {
    console.log('setTimeout');//8
  }, 0);
  
  async1();
  
  new Promise(function (resolve) {
    console.log('promise1'); //4
    resolve();
  }).then(function () {
    console.log('promise2');//7
  });
  console.log('script end'); //5



// 执行结果：

//   promise.js:10 script start
//   promise.js:2 async1 start
//   promise.js:7 async2
//   promise.js:19 promise1
//   promise.js:24 script end
//   promise.js:4 async1 end
//   promise.js:22 promise2
//   promise.js:13 setTimeout
```

JavaScript的事件循环遵循以下优先级：
> 1.首先执行所有同步代码 （执行栈）
2.然后执行所有微任务 （Microtasks Queue）
1. 最后执行宏任务 （Macrotasks Queue）

逐行解析执行过程:
> * script start （行10）：执行全局同步代码的第一条输出
* async1 start （行2）：调用async1()函数，执行其内部的同步代码
* *async2 （行7）：async1内部调用async2()，执行其同步代码
promise1 （行19）：创建Promise对象，执行其构造* 函数中的同步代码
* script end （行24）：执行全局最后一条同步代码
此时同步代码执行完毕，开始执行微任务队列：
* async1 end （行4）：async2()返回的Promise完成后，执行async1中await后面的代码
* promise2 （行22）：Promise构造函数中的resolve()触发then回调，作为微任务执行
* 微任务队列清空后，开始执行宏任务队列：
* setTimeout （行13）：执行setTimeout的回调函数

</details>


## JS 异步执行顺序


### 1、手写 Promise「百度1、百度贴吧1」






### 2、手写 Promise.all「天眼查1、滴滴1、小米2、滴滴1」

[参考：看了就会，手写Promise原理，最通俗易懂的版本！！！](https://juejin.cn/post/6994594642280857630) + SY 💛💛

<details>
  <summary>手写Promise.all</summary>

```
static all(promises) {
  const result = []
  let count = 0
  return new MyPromise((resolve, reject) => {
    const addData = (index, value) => {
        result[index] = value
        count++
        if (count === promises.length) resolve(result)
    }
    promises.forEach((promise, index) => {
        if (promise instanceof MyPromise) {
            promise.then(res => {
                addData(index, res)
            }, err => reject(err))
        } else {
            addData(index, promise)
        }
    })
  })
}
```

</details>


### 3、手写 Promise.race

<details>
  <summary>手写 Promise.race「SY」</summary>

```
```

</details>


### 4、手写 Promise.allSettled



<details>
  <summary>手写 Promise.allSettled</summary>

```
static allSettled(promises) {
  return new Promise((resolve, reject) => {
    const res = []
    let count = 0
    const addData = (status, value, i) => {
      res[i] = {
          status,
          value
      }
      count++
      if (count === promises.length) {
          resolve(res)
      }
    }
    promises.forEach((promise, i) => {
      if (promise instanceof MyPromise) {
        promise.then(res => {
          addData('fulfilled', res, i)
        }, err => {
          addData('rejected', err, i)
        })
      } else {
        addData('fulfilled', promise, i)
      }
    })
  })
}
```

</details>


### 5、手写红绿灯-Promise


<details>
  <summary>手写红绿灯</summary>

```
function red() {
  console.log('red')
}

function green() {
  console.log('green')
}

function yellow() {
  console.log('yellow')
}

function light(cb, wait) {
  return new Promise((resolve) => {
    setTimeout(() => {
      cb()
      resolve()
    }, wait)
  })
}

function start() {
  return Promise.resolve()
    .then(() => {
      return light(red, 1000)
    })
    .then(() => {
      return light(green, 1000)
    })
    .then(() => {
      return light(yellow, 1000)
    })
    .finally(() => {
      return start()
    })
}

start()
```

</details>

### 6、数组随机打乱「最右1、百度贴吧 1」

> 力扣384. 打乱数组

<details>
  <summary>数组随机打乱2种方法-Own</summary>

数组随机打乱方式：
* for循环，每个值随机另取一个下标，调换俩值
* 随机取数组中的某个值，push进新数组，删除原数组该值，直到原数组无值

前置知识：    
* Math.random() 方法可返回介于 0 ~ 1 之间的一个随机数。
* 0-9的随机数：Math.floor(Math.random()*10)
* 1-10的随机数：Math.floor(Math.random()*10)+1
*  0-n-1的随机数：Math.floor(Math.random()*n+1)
* splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。会改变原始数组。
* splice(index,howmany,item1,.....,itemX)，howmany要删除的项目数量；item1可选。向数组添加的新项目。
* 延伸 slice(start,end) end可选规定从何处结束选取。不会改变原数组

      

 a.for循环，每个值随机[random]另取一个下标，调换俩值
```
function reset(arr) {
    for (let i = 0; i < arr.length; i++) {
        var index2 = Math.floor(Math.random() * arr.length);
        const [val1, val2] = [arr[i], arr[index2]] //解构赋值
        arr[i] = val2;
        arr[index2] = val1;
    }
    return arr;
}
```

b.随机[random]取数组中的某个值，push进新数组，删除原数组该值，直到原数组无值

```
function reset(arr) {
    let res = []
    console.log(arr)
    while (arr.length) {
        let index = Math.floor(Math.random() * arr.length)
        res.push(arr[index]) //push随机取的值
        arr.splice(index, 1) //将改值删除
    }
    return res;
}
```

</details>


### 7、驼峰命名法 和 下划线命名法 互相转换「快手 1」

<details>
  <summary>驼峰命名法 和 下划线命名法 互相转换 -Own</summary>

前置知识：    
* **stringObject.split**(separator,howmany) ：方法用于把一个字符串分割成字符串数组。**separator 字符串或正则表达式**;
* **arrayObject.join**(separator)：方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。
* **arrayObject.splice**()方法向/从数组中添加/删除项目，然后返回被删除的项目,该方法会改变原始数组。
* **stringObject.toUpperCase**()：用于把字符串转换为大写。
* **stringObject.toLowerCase**()：用于把字符串转换为小写。

      

a.下划线转驼峰
```
// hello_world_web => helloWorldWeb
function translate(str){
    let arr=str.split('_') //[hello,world,web]
    let res=arr[0] //hello
    for (let i = 1; i < arr.length; i++) {
        let itemarr=arr[i].split('') // [w,o,r,l,d]
        itemarr.splice(0,1,itemarr[0].toUpperCase()) //[W,o,r,l,d]
        res+=itemarr.join('')//+World +Web
    }
    return res;
}
```

b.驼峰转下划线

```
// helloWorldWeb => hello_world_web 
function translate(str) {
    let arr = str.split('')
    let res = ""
    for (let i = 0; i < arr.length; i++) {
        let item = arr[i] == arr[i].toUpperCase() ? '_' + arr[i].toLowerCase() : arr[i];
        res += item;
    }
    return res;
}
```

</details>


### 8、手写 filter、map、reduce、find 「小米1」


<details>
  <summary>手写 filter</summary>

> filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。     
不会改变原始数组。


```
Array.prototype.filter1 = function (fn) {
    let res=[]
    for (let i = 0; i < this.length; i++) {
        if(fn(this[i])){
            res.push(this[i])
        }
        //等价于 fn(this[i]) && res.push(this[i])
    }
    return res;
}
//校验
let arr = [1, 3, 5, 10];
let arr1 = arr.filte1r(function (item) {
    return item > 4
})
console.log(arr1) //[5,10]
```

</details>


<details>
  <summary>手写 map 映射</summary>

> map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。  
不会改变原始数组。

```
Array.prototype.map1=function(fn){
    let res=[]
    for (let i = 0; i < this.length; i++) {
        res.push(fn(this[i]))
    }
    return res
}
// 校验
let arr = [1, 3, 6, 10];
let arr1 = arr.map1(function (item) {
    return item + 1
})
console.log(arr1) //[2, 4, 7, 11]
```


</details>

<details>
  <summary>手写 reduce 累加器</summary>

> reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。  
不会改变原始数组。


a.语法：

``` 
arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])
```
callback 执行数组中每个值的函数，包含四个参数：

* `accumulator`
累计器累计回调的返回值; 它是上一次调用回调时返回**累积值或initialValue**。
* `currentValue`
数组中**正在处理的元素**。
* `index` 可选
数组中正在处理的**当前元素的索引**。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。
* `array`可选
**调用reduce()的数组**

 `initialValue`可选

* **作为第一次调用 callback函数时的第一个参数的值。** 如果没有提供初始值，则将使用数组中的第一个元素。 

注：在没有初始值的空数组上调用 reduce 将报错。

* 代码实现
```
Array.prototype.reduce1 = function (fn,initVal){
    for (let i = 0; i < this.length; i++) {
        initVal=fn(initVal,this[i],i,this)
    }
    return initVal
}

var arr = [1, 4, 6, 8];
let result = arr.reduce1(function (val, item, index, origin) {
    return val + item
}, 0);
console.log(result) //19
```



</details>


<details>
  <summary>手写 find</summary>


> find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。       
不会改变原始数组。

```
 Array.prototype.find1=function (fn){
    for (let i = 0; i < this.length; i++) {
        if (fn(this[i])) {
            return this[i]
        }
    }
}
let arr = [1, 3, 6, 10];
let arr1 = arr.find1(function (item) {
    return item >4;
})
console.log(arr, arr1) // [1, 3, 6, 10] 6
```

</details>


### 9、千位分隔符「最右1」



<details>
  <summary>千位分隔符-Own</summary>

思路：

* 1) 判断是否为数字格式，不是的话返回
* 2) 用`str.split()`方法将字符串分为小数部分和整数部分
* 3) 处理整数部分，转为数组格式并`arr.reverse()`反转数组
* 4) 遍历反转后的数组，在索引为 3 的倍数位置添加','
* 5) 最后将结果数组反转回来转为字符串并拼接小数部分返回

      

代码实现:
```
// 14322093=>14,322,093
function format(num){
    if(!(typeof num === "number")) return "非数字格式";
    let arr = num.toString().split('.')//想小数和整数部分分割
    let intStr=arr[0] //取整数部分
    let decStr=arr.length >1?'.'+arr[1]:""//取小数部分
    // 处理整数部分 14322093=>14,322,093
    var arrReverse=intStr.split('').reverse()//反转数组
    var arr2=[arrReverse[0]]//结果数组初始化化
    for (let i = 1; i < arrReverse.length; i++) {
        if (i%3 == 0) {
            //索引为3的整书时，添加','
            arr2.push(arrReverse[i]+',')
        }else{
            arr2.push(arrReverse[i])
        }
    }
    // 最后将数组反转回来，并转为字符串格式，拼接小数部分
    return arr2.reverse().join('')+decStr
}
```

</details>



### 10、数组字符串题 [2a2b3c -> aabbccc aabbbccc -> 2a2b3c] 「最右1」💛💛

<details>
  <summary>数组字符串题-补充</summary>
</details>